{"version":3,"file":"sycamore.js","sources":["../node_modules/knot.js/dist/knot.module.js","../src/sycamore.js"],"sourcesContent":["var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar knot = function knot() {\n  var extended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var events = Object.create(null);\n\n  function on(name, handler) {\n    events[name] = events[name] || [];\n    events[name].push(handler);\n    return this;\n  }\n\n  function once(name, handler) {\n    handler._once = true;\n    on(name, handler);\n    return this;\n  }\n\n  function off(name) {\n    var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    handler ? events[name].splice(events[name].indexOf(handler), 1) : delete events[name];\n\n    return this;\n  }\n\n  function emit(name) {\n    var _this = this;\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // cache the events, to avoid consequences of mutation\n    var cache = events[name] && events[name].slice();\n\n    // only fire handlers if they exist\n    cache && cache.forEach(function (handler) {\n      // remove handlers added with 'once'\n      handler._once && off(name, handler);\n\n      // set 'this' context, pass args to handlers\n      handler.apply(_this, args);\n    });\n\n    return this;\n  }\n\n  return _extends({}, extended, {\n\n    on: on,\n    once: once,\n    off: off,\n    emit: emit\n  });\n};\n\nexport default knot;\n","import knot from 'knot.js'\n\nexport default class Sycamore {\n\n    /**\n        --- CONSTRUCTOR ---\n    **/\n\n    constructor (data, options = {}) {\n        this.emitter = knot()\n\n        let speed\n        if (options.speed && typeof options.speed === 'number' && options.speed >= 1) {\n            speed = options.speed\n        } else {\n            speed = 5\n        }\n\n        let delay\n        if (options.delay && typeof options.delay === 'number' && options.delay >= 0) {\n            delay = options.delay\n        } else {\n            delay = 0\n        }\n\n        let delayMinMax\n        if (options.delayMinMax && Array.isArray(options.delayMinMax) && options.delayMinMax.length === 2 && options.delayMinMax[0] > 0 && options.delayMinMax[1] > 0 && options.delayMinMax[0] < options.delayMinMax[1]) {\n            delayMinMax = options.delayMinMax\n        } else {\n            delayMinMax = false\n        }\n\n        let characterDependentWait\n        if (options.characterDependentWait !== null && typeof options.characterDependentWait === 'boolean') {\n            characterDependentWait = options.characterDependentWait\n        } else {\n            characterDependentWait = true\n        }\n\n        let firstMessage\n        if (options.firstMessage && typeof options.firstMessage === 'string') {\n            firstMessage = options.firstMessage\n        } else {\n            firstMessage = false\n        }\n\n        let autoNext\n        if (options.autoNext !== null && typeof options.autoNext === 'boolean') {\n            autoNext = options.autoNext\n        } else {\n            autoNext = true\n        }\n\n        this.options = {\n            speed: speed,\n            delay: delay,\n            delayMinMax: delayMinMax,\n            characterDependentWait: characterDependentWait,\n            firstMessage: firstMessage,\n            autoNext: autoNext\n        }\n\n        const averageCharactersPerSecond = 6\n        this.charactersPerSecond = (averageCharactersPerSecond * 2) * (this.options.speed / 10)\n\n        this.currentQuestion = false\n        this.nextMessage = false\n        this.conversationFinished = false\n        this.answeredData = []\n        this.variables = {}\n\n        if (data instanceof Array) {\n            this.data = data\n        } else if (data) {\n            throw new Error(`Data is not an array.`)\n        }\n\n        return this\n    }\n\n    /**\n        --- API ---\n    **/\n\n    init (id) {\n        if (id) {\n            this._findAndProcessDataObj(id)\n        } else if (this.options.firstMessage) {\n            this._findAndProcessDataObj(this.options.firstMessage)\n        } else {\n            this._processDataObj(this.data[0])\n        }\n    }\n\n    answer (answer) {\n        this._answerQuestion(answer)\n    }\n\n    next (id) {\n        if (this.conversationFinished) {\n            throw new Error(`Conversation has finished.`)\n        } else {\n            if (options.autoNext) {\n                throw new Error(`autoNext option is set to true.`)\n            } else if (!this.nextMessage) {\n                throw new Error(`There is no next message object.`)\n            } else {\n                if (id && typeof id === 'string') {\n                    this._findAndProcessDataObj(id)\n                } else {\n                    this._findAndProcessDataObj(this.nextMessage)\n                }\n            }\n        }\n        \n    }\n\n    on (...args) { return this.emitter.on(...args) }\n    off (...args) { return this.emitter.off(...args) }\n\n    /**\n        --- CORE FUNCTIONS ---\n    **/\n\n    _calculateWait (question) {\n        if (this.options.characterDependentWait) {\n            const characterLength = question.length\n            let wait = characterLength / this.charactersPerSecond\n            wait = wait * 1000\n            wait = Math.round(wait)\n            return wait\n        } else {\n            return 0\n        }\n    }\n\n    _calculateDelay () {\n        if (this.options.delayMinMax) {\n            return Math.floor(Math.random() * (this.options.delayMinMax[1] - this.options.delayMinMax[0] + 1) + this.options.delayMinMax[0])\n        } else {\n            return this.options.delay\n        }\n    }\n\n    _findDataObjByID (id) {\n        return new Promise((resolve, reject) => {\n            this.data.forEach((obj) => {\n                if (obj.id === id) {\n                    resolve(obj)\n                }\n            })\n            reject('No message object found')\n        })\n    }\n\n    _processDataObj (dataObj) {\n        if (dataObj.text && dataObj.question) {\n            throw new Error(`Message object can't have both text and question key.`)\n        } else if (dataObj.text && typeof dataObj.text === 'string') {\n            this._sendMessage(dataObj)\n        } else if (dataObj.question && typeof dataObj.question === 'string') {\n            this._askQuestion(dataObj)\n        } else {\n            throw new Error(`Data object doesn't contain text or question key.`)\n        }\n    }\n\n    _findAndProcessDataObj (id) {\n        this._findDataObjByID(id).then((obj) => {\n            this._processDataObj(obj)\n        }).catch((error) => {\n            throw new Error(error)\n        })\n    }\n\n    _sendMessage (dataObj) {\n        const wait = this._calculateWait(dataObj.text)\n\n        this.emitter.emit('typing', wait)\n\n        setTimeout(() => {\n            this.emitter.emit('message', this._parseDataObj(dataObj))\n\n            if (dataObj.next && typeof dataObj.next === 'string') {\n                if (this.options.autoNext) {\n                    const delay = this._calculateDelay()\n                    this.emitter.emit('delay', delay)\n\n                    setTimeout(() => {\n                        this._findAndProcessDataObj(dataObj.next)\n                    }, delay)\n                } else {\n                    this.nextMessage = dataObj.next\n                }\n            } else {\n                this._finalData()\n                this.conversationFinished = true\n            }\n        }, wait)\n    }\n\n    _askQuestion (dataObj) {\n        this.currentQuestion = dataObj\n        const wait = this._calculateWait(dataObj.question)\n\n        this.emitter.emit('typing', wait)\n\n        setTimeout(() => {\n            this.emitter.emit('question', this._parseDataObj(dataObj))\n        }, wait)\n    }\n\n    _answerQuestion (answerString) {\n        const answeredQuestionData = {\n            question: this.currentQuestion.question,\n            answer: answerString\n        }\n\n        this.emitter.emit('answered', answeredQuestionData)\n\n        this.answeredData.push(answeredQuestionData)\n\n        this.emitter.emit('update', this.answeredData)\n\n        if (this.currentQuestion.input) {\n            let newVariable = {\n                [this.currentQuestion.input.variable]: answerString\n            }\n            \n            let newVariables = Object.assign(this.variables, newVariable)\n\n            this.variables = newVariables\n\n            if (this.currentQuestion.next && typeof this.currentQuestion.next === 'string') {\n                if (this.options.autoNext) {\n                    const delay = this._calculateDelay()\n                    this.emitter.emit('delay', delay)\n    \n                    setTimeout(() => {\n                        this._findAndProcessDataObj(this.currentQuestion.next)\n                    }, delay)\n                } else {\n                    this.nextMessage = this.currentQuestion.next\n                }\n            } else {\n                this._finalData()\n                this.conversationFinished = true\n            }\n        } else if (this.currentQuestion.answers) {\n            this.currentQuestion.answers.forEach((answer) => {\n                if (answer.text === answerString) {\n                    if (answer.next && typeof answer.next === 'string') {\n                        if (this.options.autoNext) {\n                            const delay = this._calculateDelay()\n                            this.emitter.emit('delay', delay)\n            \n                            setTimeout(() => {\n                                this._findAndProcessDataObj(answer.next)\n                            }, delay)\n                        } else {\n                            this.nextMessage = answer.next\n                        }\n                    } else {\n                        this._finalData()\n                        this.conversationFinished = true\n                    }\n                }\n            })\n        }\n    }\n\n    _finalData () {\n        let data = {\n            data: this.answeredData,\n            variables: this.variables\n        }\n\n        this.emitter.emit('finished', data)\n    }\n\n    _parseDataObj (dataObj) {\n        for (let key in this.variables) {\n            if (dataObj.text) {\n                dataObj.text = dataObj.text.replace('${' + key + '}', this.variables[key])\n            } else if (dataObj.question) {\n                dataObj.question = dataObj.question.replace('${' + key + '}', this.variables[key])\n            }\n        }\n        return dataObj\n    }\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","knot","on","name","handler","events","push","this","once","_once","off","undefined","splice","indexOf","emit","_this","_len","args","Array","_key","cache","slice","forEach","apply","extended","create","Sycamore","data","options","emitter","speed","delay","delayMinMax","isArray","characterDependentWait","firstMessage","autoNext","averageCharactersPerSecond","charactersPerSecond","currentQuestion","nextMessage","conversationFinished","answeredData","variables","Error","id","_findAndProcessDataObj","_processDataObj","answer","_answerQuestion","question","characterLength","wait","Math","round","floor","random","Promise","resolve","reject","obj","dataObj","text","_sendMessage","_askQuestion","_findDataObjByID","then","catch","error","_calculateWait","_this3","_parseDataObj","next","_calculateDelay","_finalData","_this4","answerString","answeredQuestionData","input","newVariable","variable","newVariables","_this5","answers","replace"],"mappings":"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"}